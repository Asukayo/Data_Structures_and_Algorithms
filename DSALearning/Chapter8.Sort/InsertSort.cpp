//
// Created by 86150 on 2023/9/22.
//
//由插入排序可以引出三种重要的排序算法、直接插入排序，折半插入排序和希尔排序


//直接排序的空间复杂度时O(1)   但时间复杂度达到了O(n^2)
void PlainInsertSort(int A[],int n){        //n为数组A的长度
    int i,j;
    for(i = 2;i<=n;i++){        // 0位置要用作哨兵 1必定自身是有序的，所以从2开始
        if(A[i]<A[i-1]) {        //当A[i]比前一个元素要小的时候，说明要插入重新排序
            A[0] = A[i];        //将要插入的元素放在A[0]的位置作为哨兵
            for (j = i - 1; A[0] < A[j]; j--) {
                //从后往前遍历，如果A[j]比A[0]大的时候，说明要将当前的元素后移，采用了哨兵，最多当j = 0 时就会结束循环，减少了判断条件
                A[j + 1] = A[j];      //将当前元素后移一位
            }
            A[j + 1] = A[0];  //遍历结束，此时A[j]所指的元素 <= A[0] 所以将A[j+1]里的元素改成A[0]
        }
    }
}


//折半插入排序
 void HalfInsertSort(int A[],int n){
    int i,j,low,mid,high;
    for(i = 2;i<=n;i++){
        if(A[i]<A[i-1]){
            A[0] = A[i];
            low = 1;
            high = i - 1;   //用来查找的区间是[1,i-1]
            while(low<=high){        //此处使用折半查找来找到应该插入的位置，这也是折半查找和直接插入排序本质的区别
                mid = (low+high)/2;  //向下取整得到mid的值
                if(A[mid]<A[0]){
                    high = mid - 1;
                }else{
                    low = mid + 1;
                }
            }                                   //遍历结束之后low = high + 1 而low的值就是当前元素应当插入的位置
            for (j = i-1;  j >= low;j--) {
                A[j+1] = A[j];  //将元素后移一位
            }
            A[low] = A[0];
        }

    }
}